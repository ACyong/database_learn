# SQL 介绍：
> 结构化查询语句（Structured Query Language），SQL 用来和数据库打交道，完成和数据库的交互。SQL 是一套标准，但是每一个数据库都有自己才有的特性。
---


## 1、SQL 语句按功能划分

1. 数据定义语言（DDL-Date Definition Language），针对结构的操作
> 它用来定义我们的数据库对象，包括数据库、数据表和列。通过使用 DDL，可以创建，删除和修改数据库和表结构。代表关键字：CREATE、DROP 和 ALTER

2. 数据查询语句（DQL-Data Query Language），针对表中数据的操作
> 用它查询想要的记录，代表关键字：SELECT

3. 数据操作语言（DML-Data Manipulation Language），针对表中数据的操作
> 用它操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。代表关键字：INSERT、DELETE、UPDATE

4. 数据控制语言（DCL-Data Control Language）
> 用它来定义访问权限和安全级别。代表关键字：GRANT、REVOKE

5. 事务控制语言（TCL-Transaction Control Language）
> 不同数据库情况不一样，以MySQL为例，代表关键字：COMMIT、ROLLBACK

注意：好的代码规范是提高效率的关键，关于 SQL 大小写的问题
```
1、表名、表别名、字段名、字段别名等都小写；
2、SQL 保留字、函数名、绑定变量等都大写。
```
---


## 2、名词介绍：

1. DB（Database）就是数据库，存储数据的仓库，可以把它理解为多个数据表的集合。

2. DBMS（Database Management System），数据库管理系统或管理数据库的软件，DBMS = 多个数据库（DB） + 管理程序。

3. DBS（Database System），数据库系统，DBS = DB（存储）+ DBMS（数据库软件）+ 数据库应用 + 用户
---


## 3、MySQL 中的 SQL 是如何执行的

1. 连接层：客户端和服务器端通过连接器建立连接后，客户端发送 SQL 至服务器端；
```
连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：
mysql -h$ip -P$port -u$user -p
```

注意：
```
密码也可以直接跟在 -p 后面写在命令行中，但这样可能会导致密码泄露。如果连的是生产服务器，强烈建议不要这么做。连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证身份，这个时候用的就是输入的用户名和密码。如果用户名或密码不对，就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。如果用户名密码认证通过，连接器会到权限表里面查出该用户拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。可以在 SHOW PROCESSLIST 命令中看到建立的连接及其状态。客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 wait_timeout 控制的，默认值是 8 小时。
```

```
建立连接的过程通常是比较复杂的，所以在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。但是全部使用长连接后，可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。怎么解决这个问题呢？可以考虑以下两种方案。

1、定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2、如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。
```

2. SQL 层：对 SQL 语句进行查询处理；
```
1、查询缓存：Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为只要有对一个表的更新，这个表上所有的查询缓存都会被清空，所以查询缓存往往效率不高，除非业务就是有一张静态表，很长时间才会更新一次，好在 MySQL 也提供了这种“按需使用”的方式。可以将参数 query_cache_type 设置成 DEMAND，这样对于默认的 SQL 语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：mysql> select SQL_CACHE * from T where ID=10;在 MySQL8.0 之后就抛弃了这个功能。

2、解析器：在解析器中对 SQL 语句进行语法分析、语义分析。

3、优化器：在优化器中会确定 SQL 语句的执行路径，比如是根据全表检索，还是根据索引来检索，或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。

4、执行器：在执行之前需要判断该用户是否具备权限，如果具备权限就执行 SQL 查询并返回结果。在 MySQL8.0 以下的版本，如果设置了查询缓存，这时会将查询结果进行缓存。可以使用 select version(); 来查看 MySQL 的版本情况。
```

3. 存储引擎层：与数据库文件打交道，负责数据的存储和读取。常见的存储引擎：
```
1、InnoDB 存储引擎：它是 MySQL 5.5 版本之后默认的存储引擎，最大的特点是支持事务、行级锁定、外键约束等。

2、MyISAM 存储引擎：在 MySQL 5.5 版本之前是默认的存储引擎，不支持事务，也不支持外键，最大的特点是速度快，占用资源少。

3、Memory 存储引擎：使用系统内存作为存储介质，以便得到更快的响应速度。不过如果 mysqld 进程崩溃，则会导致所有的数据丢失，因此我们只有当数据是临时的情况下才使用 Memory 存储引擎。

4、NDB 存储引擎：也叫做 NDB Cluster 存储引擎，主要用于 MySQL Cluster 分布式集群环境，类似于 Oracle 的 RAC 集群。

5、Archive 存储引擎：它有很好的压缩机制，用于文件归档，在请求写入时会进行压缩，所以也经常用来做仓库。
```

注意：由于MySQL的存储引擎各有特点，常用的有：MyISAM的使用场景为读写分离的读库， 而InnoDB为写库

---


## 4、如何在 MySQL 中对一条 SQL 语句的执行时间进行分析

1. 需要看下 profiling 是否开启，开启它可以让 MySQL 收集在 SQL 执行时所使用的资源情况，命令如下：
```
mysql> SELECT @@profiling;
```

2. profiling=0 代表关闭，我们需要把 profiling 打开，即设置为 1
```
mysql> SET profiling=1;
```

3. 执行一个 SQL 查询。

4. 查看当前会话所产生的所有 profiles:
```
mysql> SHOW profiles;
```

5. 如果想要获取上一次查询的执行时间，可以使用：
```
mysql> SHOW profile;
```

6. 查询指定的 Query ID
```
mysql> SHOW profile FOR QUERY 2;
```
