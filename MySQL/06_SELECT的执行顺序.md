# SELECT的执行顺序
> 查询是 RDBMS 中最频繁的操作。在理解 SELECT 语法的时候，还需要了解 SELECT 执行时的底层原理。只有这样，才能对 SQL 有更深刻的认识
---

## 1、执行顺序总结
```
1、FROM子句组装数据
2、WHERE子句进行条件筛选
3、GROUP BY分组 
4、使用聚集函数进行计算； 
5、HAVING筛选分组； 
6、计算所有的表达式； 
7、SELECT 的字段；
8、ORDER BY排序
9、LIMIT筛选
```

## 1、limit(永远放在SQL语句的最后写)
```
1、作用 ：限制显示查询记录的记录个数
2、用法
    1、limit n -->显示几条记录
    2、limit m, n
3、注意：
    1、m - > 从第几条记录开始显示，n 表示显示几条
    2、m的值是从0 开始计算的，3 则表示第四条记录
```

2. order by
```
1、作用：给查询的结果进行排序
2、语法格式：order by 字段名 排序方式;
3、排序方式：ASC(默认) 升序，DESC 降序
```

注意：
```
关于ORDER BY字段是否增加索引：

在MySQL中，支持两种排序方式：FileSort和Index排序。Index排序的效率更高，
Index排序：索引可以保证数据的有序性，因此不需要再进行排序。
FileSort排序：一般在内存中进行排序，占用CPU较多。如果待排结果较大，会产生临时文件I/O到磁盘进行排序，效率较低。
所以使用ORDER BY子句时，应该尽量使用Index排序，避免使用FileSort排序。
当然具体优化器是否采用索引进行排序，你可以使用explain来进行执行计划的查看。

优化建议：
1、SQL中，可以在WHERE子句和ORDER BY子句中使用索引，目的是在WHERE子句中避免全表扫描，ORDER BY子句避免使用FileSort排序。
当然，某些情况下全表扫描，或者FileSort排序不一定比索引慢。但总的来说，我们还是要避免，以提高查询效率。
一般情况下，优化器会帮我们进行更好的选择，当然我们也需要建立合理的索引。
2、尽量Using Index完成ORDER BY排序。
如果WHERE和ORDER BY相同列就使用单索引列；如果不同使用联合索引。
3、无法Using Index时，对FileSort方式进行调优。
```

```
关于SELECT 语句不加 ORDER BY 如何排序:
SELECT 不加 “ORDER BY”时， MySQL 会尝试以尽可能快的方法返回数据。

MyISAM 表
MySQL Select 默认排序是按照物理存储顺序显示的。（不进行额外排序）
也就是说SELECT * FROM tbl – 会产生全表扫描。如果表没有删除、替换、更新操作，记录会显示为插入的顺序。

InnoDB 表
同样的情况，会按主键的顺序排列。这只是潜规则，是不靠谱的

结论：不能依赖 MySQL 的默认排序，想排序，总是加上 ORDER BY 的
```
---


    5、group by
        1、作用：给查询的结果进行分组
        2、注意：
            1、group by后的字段名必须要为select之后的字段名
            2、group by处理的是group by之后的所有字段，如果查询字段和group by之后的字段不一致，则必须要对该字段值做聚合处理(聚合函数)

    4、聚合函数
        1、分类
            1、avg(字段名) : 求字段的平均值
            2、sum(字段名) : 求字段的和
            3、max(字段名) : 求字段的最大值
            4、min(字段名) : 求字段的最小值
            5、count(字段名) : 统计该字段的记录的个数

    6、having
        1、作用：对查询的结果进行进一步筛选
        2、注意：
            1、having语句通常与group by语句联合使用，用来过滤由group by语句返回的记录集，作为筛选分组的条件。
            2、having语句的存在弥补了where关键字不能与聚合函数联合使用的不足，where操作的是表中实际存在的字段，having操作的是聚合函数生成的显示列，WHERE子句用于对查询结果的分组前，通过WHERE来过滤。而HAVING子句用于筛选满足条件的组，用于在分组之后进行过滤

    7、distinct
        1、作用：不显示字段的重复值

    8、查询表记录时做数学运算
        1、运算符
            +  -  *  /  %
