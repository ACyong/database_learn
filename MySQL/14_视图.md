# 视图
> MySQL 的视图是一种虚拟表，本身是不具有数据，行和列的数据来自于定义视图的查询中所使用的表，并且还是在使用视图时动态生成的。它相当于是一张表或多张表的数据结果集, 封装了底层与数据表的接口


## 1. 创建视图
```
CREATE [ALGORITHM = TEMPTABLE/MERGE/UNDEFINED] VIEW view_name AS
SELECT column1, column2
FROM table
WHERE condition
```

视图算法:
```
undefined：未定义（默认的），这不是一种实际使用的算法，而是一个“推卸责任”的算法。在未定义的情况下，告诉系统，视图没有定义算法，请自己选择。

temptable：临时表算法，系统先执行视图的select语句，后执行外部查询语句。

merge：合并算法，系统先将视图对应的select语句与外部查询视图的select语句进行合并，然后再执行。此算法比较高效，且在未定义算法的时候，经常会默认选择此算法。
```

实际上就是在 SQL 查询语句的基础上封装了视图 VIEW，这样就会基于 SQL 语句的结果集形成一张虚拟表。其中 view_name 为视图名称，column1、column2 代表列名，condition 代表查询过滤条件。当视图创建之后，它就相当于一个虚拟表，可以直接使用
```
SELECT * FROM view_name
```

## 2. 嵌套视图
当创建好一张视图之后，还可以在它的基础上继续创建视图


## 3. 修改视图
```
ALTER VIEW view_name AS
SELECT column1, column2
FROM table
WHERE condition
```
语法和创建视图一样，只是对原有视图的更新


## 4. 删除视图
```
DROP VIEW view_name
```


## 5. 视图的优缺点

优点：
```
1）简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。
2）安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。
3）数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。
```
总而言之，使用视图的大部分情况是为了保障数据安全性，提高查询效率(指的是编写查询语句的效率)。

缺点：
```
1）性能差：数据库必须把视图查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也要把它变成一个复杂的结合体，需要花费一定的时间。
2）修改限制：当用户试图修改视图的某些信息时，数据库必须把它转化为对基本表的某些信息的修改，对于简单的视图来说，这是很方便的，但是，对于比较复杂的试图，可能是不可修改的。
```
