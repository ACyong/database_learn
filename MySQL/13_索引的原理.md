# 索引的原理
> 数据库中的索引，就好比一本书的目录，它可以帮我们快速进行特定值的定位与查找，从而加快数据查询的效率。索引是帮助数据库管理系统高效获取数据的数据结构。

# 1. 创建索引注意事项
> 创建索引有一定的规律。当这些规律出现的时候，可以通过创建索引提升查询效率

## 1. 什么情况下可以创建索引：

1. 字段的数值有唯一性的限制，比如用户名, 索引本身可以起到约束的作用，比如唯一索引、主键索引都是可以起到唯一性约束的，因此在数据表中，如果某个字段是唯一性的，就可以直接创建唯一性索引，或者主键索引。

2. 频繁作为 WHERE 查询条件的字段，尤其在数据表大的情况下在数据量大的情况下，某个字段在 SQL 查询的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。创建普通索引就可以大幅提升数据查询的效率。

3. 需要经常 GROUP BY 和 ORDER BY 的列索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。

注意:
```
有 GROUP BY 和 ORDER BY 的情况。比如按照 user_id 进行评论分组，同时按照评论时间降序的方式进行排序，这时就需要同时进行 GROUP BY 和 ORDER BY，那么是不是需要单独创建 user_id 的索引和 comment_time 的索引呢？

SELECT user_id, count(*) as num FROM product_comment group by user_id order by comment_time desc limit 100;

实际上多个单列索引在多条件查询时只会生效一个索引（MySQL 会选择其中一个限制最严格的作为索引），所以在多条件联合查询的时候最好创建联合索引。在这个例子中，创建联合索引 (user_id, comment_time)，再来看下查询的时间，效率会提升了很多。如果创建联合索引的顺序为 (comment_time, user_id) 呢？同样比两个单列索引要快，但是会比顺序为 (user_id, comment_time) 的索引要慢一些。这是因为在进行 SELECT 查询的时候，先进行 GROUP BY，再对数据进行 ORDER BY 的操作，所以按照这个联合索引的顺序效率是最高的。

创建联合索引的时候，最好是根据字段值的区分度来排序，区分度最大的字段放在联合索引的最左侧，区分度最小的字段放在联合索引的最右侧。

如果遇到了范围条件查询，比如<、<=、>、>=、between等, 那么范围列后的列就无法使用到索引
```

4. UPDATE、DELETE 的 WHERE 条件列，一般也需要创建索引，如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。不过在实际工作中，也需要注意平衡，如果索引太多了，在更新数据的时候，如果涉及到索引更新，就会造成负担。

5. DISTINCT 字段需要创建索引

6. 做多表 JOIN 连接操作时，创建索引需要注意以下的原则
首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 user_id 在 product_comment 表和 user 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。


## 2. 索引不是万能的，在有些情况下使用索引反而会让效率变低

1. 数据行数少的情况下
2. 区分度不高的字段, 比如性别（男或女）字段

注意:
```
不仅要看字段中的数值个数，还要根据数值的分布情况来考虑是否需要创建索引。
```


# 2. 索引的数据结构

## 1. 索引的存储位置
```
数据库服务器有两种存储介质，分别为硬盘和内存。内存属于临时存储，容量有限，而且当发生意外时（比如断电或者发生故障重启）会造成数据丢失；硬盘相当于永久存储介质，这也是为什么需要把数据保存到硬盘上。虽然内存的读取速度很快，但还是需要将索引存放到硬盘上，这样的话，当我们在硬盘上进行查询时，也就产生了硬盘的 I/O 操作。相比于内存的存取来说，硬盘的 I/O 存取消耗的时间要高很多。通过索引来查找某行数据的时候，需要计算产生的磁盘 I/O 次数，当磁盘 I/O 次数越多，所消耗的时间也就越大。如果能让索引的数据结构尽量减少硬盘的 I/O 操作，所消耗的时间也就越小。
```

## 为什么使用 B 树
二分查找法是一种高效的数据检索方式，时间复杂度为 O(log2n)，是不是采用二叉树就适合作为索引的数据结构呢？我们先来看下最基础的二叉搜索树（Binary Search Tree），搜索某个节点和插入节点的规则一样，我们假设搜索插入的数值为 key：如果 key 大于根节点，则在右子树中进行查找；如果 key 小于根节点，则在左子树中进行查找；如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。举个例子，我们对数列（34，22，89，5，23，77，91）创造出来的二分查找树如下图所示：
