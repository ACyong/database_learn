# 事务
> 事务保证了一次处理的完整性，也保证了数据库中的数据一致性。它是一种高级的数据处理方式，如果在增加、删除、修改的时候某一个环节出了错，它允许回滚还原，要么完全执行，要么都不执行
---

## 1. 事务的特性: ACID

1. A，也就是原子性（Atomicity）。
```
原子的概念就是不可分割，可以把它理解为组成物质的基本单位，也是进行数据处理操作的基本单位。
```

2. C，就是一致性（Consistency）。
```
一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。
```

3. I，就是隔离性（Isolation）。
```
指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。
```

4. D，指的是持久性（Durability）。
```
事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态
```

注意:
```
原子性是基础，隔离性是手段，一致性是约束条件，而持久性是目的
```


## 2. 事务的常用控制语句
```
START TRANSACTION 也可以使用START TRANSACTION 的别名 BEGIN 或  BEGIN WORK，作用是显式开启一个事务。

COMMIT：提交事务。当提交事务后，对数据库的修改是永久性的。

ROLLBACK 或者 ROLLBACK TO [SAVEPOINT]，意为回滚事务。意思是撤销正在进行的所有没有提交的修改，或者将事务回滚到某个保存点。

SAVEPOINT：在事务中创建保存点，方便后续针对保存点进行回滚。一个事务中可以存在多个保存点。

RELEASE SAVEPOINT：删除某个保存点。

SET TRANSACTION，设置事务的隔离级别。

SET @@completion_type = 1;
```

注意:
```
使用事务有两种方式，分别为隐式事务和显式事务。隐式事务实际上就是自动提交，Oracle 默认不自动提交，需要手写 COMMIT 命令，而 MySQL 默认自动提交，当然可以配置 MySQL 的参数：

mysql> set autocommit =0;  //关闭自动提交
mysql> set autocommit =1;  //开启自动提交

设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。
```
```
completion_type 参数的作用:

completion=0，这是默认情况。也就是说当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要使用 START TRANSACTION 或者 BEGIN 来开启。

completion=1，这种情况下，当提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启一个链式事务，即当提交事务之后会开启一个相同隔离级别的事务。

completion=2，这种情况下 COMMIT=COMMIT AND RELEASE，也就是当提交后，会自动与服务器断开连接。
```


## 3. 事务并发处理可能存在的异常

1. 脏读（Dirty Read）
> 读到了其他事务还没有提交的数据。

2. 不可重复读（Nnrepeatable Read）
> 对某数据进行读取，发现两次读取的结果不同，也就是说没有读到相同的内容。这是因为有其他事务对这个数据同时进行了修改或删除。

3. 幻读（Phantom Read）
> 事务 A 根据条件查询得到了 N 条数据，但此时事务 B 更改或者增加了 M 条符合事务 A 查询条件的数据，这样当事务 A 再次进行查询的时候发现会有 N+M 条数据，产生了幻读。


## 4. 事务隔离级别

|        | 脏读 | 不可重复读 | 幻读 |
| ------ | ------- | ---- |      |
| 读未提交（READ UNCOMMITTED ）| 允许 | 允许 | 允许 |
| 读已提交（READ COMMITTED）   | 禁止 | 允许 | 允许 |
| 可重复读（REPEATABLE READ）  | 禁止 | 禁止 | 允许 |
| 可串行化（SERIALIZABLE）     | 禁止 | 禁止 | 禁止 |

1. 读未提交：
```
在这个隔离级别下，事务A会读到事务B未提交的数据，在事务B回滚后，事务A读到的数据无意义，是脏数据，称为 脏读
```

2. 读已提交：
```
在这个隔离级别下，只有在事务B已提交时，事务A才能读到，如果事务A先查询id为1的记录，之后事务B修改这条记录并提交，事务A再读取，两次结果会不一致，所以不可重复读。如果想要避免不可重复读或者幻读，就需要在 SQL 查询的时候编写带加锁的 SQL 语句
```

3. 可重复读：
```
在这个隔离级别下，就算事务B的修改已经提交，事务A读到的数据依旧是一致的。当事务B插入一条新数据并提交之后，事务A查询不到当前数据，查询不到就以为不存在，但是事务A却可以更新这条数据成功，并且更新后再次查询，数据出现了。一开始查询不到，但能修改，再次查询又出现了，跟幻觉一样，所以称为　幻读
```

4. 可串行化:
```
将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。
```

注意:
```
MySQL 默认的隔离级别是可重复读
Oracle 和 SQL Server默认隔离级别是读已提交
```

隔离级别越高，就越影响系统的并发性能
```
1、因为隔离级别越高就是越接近串行化操作（隔离级别最高的就是：可串行化）。而串行化操作就是按照事务的先后顺序，排队执行，一个事务操作可能就要等待很久才能执行，并发执行的效率就没有了。

2、隔离就是给资源加锁，隔离级别越低，资源的共享程度就越高，大家都能去取自己需要的资源，而隔离级别高，共享程度越低

「不可重复读」就是针对于单独的某条数据同一事务前后读取不一致（被其他事务修改, 进行了UPDATE或DELETE）。
「幻读」针对于查询某一个范围的数据结果集的前后不一致，查询的数据表在事务的执行期间有执行插入删除的操作，导致查询结果的增加或减少。
```